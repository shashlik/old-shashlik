cmake_minimum_required(VERSION 2.8.12)


# General definitions
set(SHASHLIK_VERSION_STRING "0.5.0")
set(SHASHLIK_VERSION_MAJOR 0)
set(SHASHLIK_VERSION_MINOR 5)
set(SHASHLIK_VERSION_RELEASE 0)
set(SHASHLIK_VERSION_YEAR 2014)

# ----------------------------------------------------------------
# Requirements


find_package(ECM 1.0.0 REQUIRED NO_MODULE)
set(CMAKE_MODULE_PATH ${CMAKE_MODULE_PATH} ${ECM_MODULE_PATH} ${ECM_KDE_MODULE_DIR} ${CMAKE_SOURCE_DIR}/cmake)


# For Qt5 and KF5 stuff, you must set the CMake module path first. See
# BUILDING for how to do that.

find_package(Qt5 NO_MODULE COMPONENTS Core Quick Gui Widgets)

# set(KF5_VERSION "5.0.0") # handled by release scripts
# set(KF5_DEP_VERSION "5.0.0") # handled by release scripts

# CMake include files. Paths are generated by the find_package calls above(?)
include(FeatureSummary)
include(GenerateExportHeader)
include(ECMGenerateHeaders)
include(KDEInstallDirs)
include(KDECMakeSettings)
include(ECMPackageConfigHelpers)
include(ECMSetupVersion)
include(ECMInstallIcons)

find_package(KF5 COMPONENTS I18n WindowSystem Service Package Declarative Plasma PlasmaQuick)
# find_package(KF5 REQUIRED COMPONENTS
# WindowSystem CoreAddons Solid Config Auth DBusAddons
# I18n Service IconThemes Bookmarks
# Plasma PlasmaQuick Declarative KIO KDELibs4Support
# )

find_package(OpenSSL REQUIRED)
find_package(OpenGL REQUIRED)

find_package(BISON)
find_package(FLEX)

find_package(Java 1.6 REQUIRED)
include(UseJava)

include(JarjarModule)

include(TestBigEndian)
TEST_BIG_ENDIAN(SystemIsBigEndian)

include(FindPkgConfig)
pkg_check_modules(DRM REQUIRED libdrm)
IF(DRM_FOUND)
    MESSAGE(STATUS "Looking for DRM - found at ${DRM_PREFIX}")
ELSE(DRM_FOUND)
    MESSAGE(STATUS "Looking for DRM - not found")
ENDIF(DRM_FOUND)

# ----------------------------------------------------------------
# System settings

if(COMMAND CMAKE_POLICY)
    if (POLICY CMP0063)
        cmake_policy(SET CMP0063 NEW)
    endif()
endif()

# It is necessary to note that we have endian.h, which we do on all systems we
# target otherwise the android code goes and redefines it all on us. Not so
# great...
add_definitions(-DHAVE_SYS_UIO_H
                -DHAVE_ENDIAN_H
                -DHAVE_OFF64_T   # FIXME: Need to investigate which gcc flags is needed to get this
                -DHAVE_SYS_SOCKET_H
                -DHAVE_PTHREADS
                -DHAVE_POSIX_CLOCKS
                -DHAVE_SYSTEM_PROPERTY_SERVER
                -D_FILE_OFFSET_BITS=64
                -DEXCLUDE_FS_CONFIG_STRUCTURES
                -DGL_GLEXT_PROTOTYPES -DEGL_EGLEXT_PROTOTYPES
                -DWL_EGL_PLATFORM
                -DSHASHLIK_ROOT="${CMAKE_INSTALL_PREFIX}"
)

# In case this file exists, we need to set this to look for certain files in the right place
if(EXISTS "/usr/include/i386-linux-gnu")
    add_definitions(-DHAS_SPECIAL_INCLUDE_DIRS=1)
endif()

# The android root directory is the installation location for the android system
# itself, and used by the vm's various bits to load and check things.
set(ANDROID_ROOT ${CMAKE_INSTALL_PREFIX}/android)
set(ANDROID_BIN_DIR ${ANDROID_ROOT}/system/bin)
set(ANDROID_LIB_DIR ${ANDROID_ROOT}/system/lib)
set(ANDROID_JAR_DIR ${ANDROID_ROOT}/system/framework)

# ----------------------------------------------------------------
# Various project settings

# This will force a 32bit build (read in various places and sets compiler/linker flags on binaries)
# The reason we do this is that the dalvik vm expects to be running as 32bit, and we can't get
# around this until a switch to art is made.
set(FORCE_32BIT_BUILD true)
if(FORCE_32BIT_BUILD)
    # This is less than beautiful, but it works for now
    link_directories(/usr/lib/)
endif(FORCE_32BIT_BUILD)

# Set JIT_VM to:
#   false   if you want to run an interpreter (currently necessary on 64 bit systems)
#   true    if you want just in time compilation to assembler
#
# false is the default
#
# FIXME: Should we perhaps have a test for 32/64 bit systems?
# NOTE: As we are basing Shashlik on KitKat at the moment, 32bit is required. When we
#       switch to Lollipop or greater, 64bit will become an option, but not until then.
set(JIT_VM true)

# This sets whether or not to build the various development helper tools which are
# not required for the normal operation of the launcher itself.
set(BUILD_TOOLS false)

# It is assumed that the various repos are checked out next to this one
# This is described in the file BUILDING.
set(GENERAL_SOURCE_PATH ${CMAKE_SOURCE_DIR}/..)

set(ANDROID_CORE_PATH              ${GENERAL_SOURCE_PATH}/android-core)
set(ANDROID_LIBCORE_PATH           ${GENERAL_SOURCE_PATH}/android-libcore)
set(ANDROID_FRAMEWORKS_NATIVE_PATH ${GENERAL_SOURCE_PATH}/android-frameworks-native)
set(ANDROID_FRAMEWORKS_BASE        ${GENERAL_SOURCE_PATH}/android-frameworks-base)
set(DALVIK_PATH                    ${GENERAL_SOURCE_PATH}/dalvik)
set(NATIVEHELPER_PATH              ${GENERAL_SOURCE_PATH}/android-libnativehelper)
set(SAFE_IOP_PATH                  ${GENERAL_SOURCE_PATH}/safe-iop)
set(SKIA_PATH                      ${GENERAL_SOURCE_PATH}/android-skia)


# Tier 1 libraries

# android-core (FIXME: Make one ANDROID_CORE_INCLUDES instead?)
set(LIBCORKSCREW_INCLUDES  ${ANDROID_CORE_PATH}/include)
set(LIBLOG_INCLUDES        ${ANDROID_CORE_PATH}/include)
set(LIBUTILS_INCLUDES      ${ANDROID_CORE_PATH}/include)
set(LIBCUTILS_INCLUDES     ${ANDROID_CORE_PATH}/include)

set(LIBANDROIDCORE_INCLUDEDIRS ${ANDROID_CORE_PATH}/include)
set(LIBANDROIDLIBCORE_INCLUDEDIRS ${ANDROID_LIBCORE_PATH}/include)

# nativehelper
set(LIBNATIVEHELPER_INCLUDES ${NATIVEHELPER_PATH}/include/nativehelper)
set(LIBNATIVEHELPER_INCLUDEDIRS ${NATIVEHELPER_PATH}/include/nativehelper ${NATIVEHELPER_PATH}/include)

# safe-iop
set(SAFE_IOP_INCLUDES ${SAFE_IOP_PATH}/include)

set(SQLITE3_INCLUDES ${GENERAL_SOURCE_PATH}/sqlite/dist ${GENERAL_SOURCE_PATH}/sqlite/android)

set(SKIA_INCLUDES ${SKIA_PATH}/include ${SKIA_PATH}/include/config ${SKIA_PATH}/include/core ${SKIA_PATH}/include/effects ${SKIA_PATH}/include/gpu ${SKIA_PATH}/include/images ${SKIA_PATH}/include/pathops ${SKIA_PATH}/include/pipe ${SKIA_PATH}/include/ports ${SKIA_PATH}/include/utils ${SKIA_PATH}/include/xml)

# Tier2 libraries

set(LIBHARDWARE_INCLUDES ${GENERAL_SOURCE_PATH}/android-libhardware/include)

# Dalvik
set(LIBDEX_INCLUDES ${DALVIK_PATH})

# frameworks/native
set(LIBUI_INCLUDES ${ANDROID_FRAMEWORKS_NATIVE_PATH}/include)
set(LIBBINDER_INCLUDES ${CMAKE_SOURCE_DIR}/src/libs/libbinder
                       ${ANDROID_FRAMEWORKS_NATIVE_PATH}/include
                       ${CMAKE_SOURCE_DIR}/src/deps/libbinder
                       ${CMAKE_INSTALL_PREFIX}/include    # FIXME: Remove when the build works without tier1/2
                       #${LIBXXX_INCLUDS}/include
)

# set(OPENGL_LIBS EGL GLESv2 GLESv1_CM)
# set(OPENGL_INCLUDES ${ANDROID_FRAMEWORKS_NATIVE_PATH}/opengl/include)

# ----------------------------------------------------------------


add_subdirectory(src)

# This must be at the end, or we end up with these post install commands being
# run before the install proccess is fully completed
add_subdirectory(postinstall)
